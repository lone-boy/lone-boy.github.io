---
layout: post
title: "操作系统 第一章 最开始的两行代码"
date: 2022-03-01
description: "操作系统学习"
tag: 操作系统
---

一直以来都想好好学一学操作系统，从底层方面来思考操作系统如何运行，并代入实际中感受操作系统的作用。从github上找到一个挺不错的开源项目，这里基于这个项目来学习操作系统。

## 前言

内容很短，但是都是实用的。

## BIOS启动

### 第一段代码

当按下开机键的那一刻，在主板上提前写死的固件程序BIOS会将硬盘中启动区的512 byte的数据原封不动复制到内存中的0x7c00这个位置，并跳转到那个位置进行执行。

![](/images/os/1.png)

启动区的定义非常简单，只要硬盘中的0盘0道1扇区的512个字节的最后两个字节分别是0x55和0xaa，那么BIOS就会认为它是一个启动区。

所以，从理解操作系统而言，此时的BIOS就是一个代码搬运工，把512字节的二进制数据从硬盘搬运到了内存中。所以作为操作系统的开发人员，仅仅需要把操作系统最开始的那段代码，编译并储存在硬盘的0盘0道1扇区即可。之后BIOS会帮我们把它放到内存里，并且跳过去执行。

而对于Linux-0.11最开始的代码，就是用汇编语言写的bootsect.s，位于boost文件夹下。

![](/images/os/2.png)

通过编译，这个bootsect.s会被编译成二进制文件，存放到启动区的第一扇区。

![](/images/os/3.png)

然后，BIOS搬运到内存的0x7c00这个位置，而CPU也会从这个位置开始，不断往后一条一条语句无脑的执行下去。

那么从这个文件第一行代码开始！

```asm
mov ax,0x07c0
mov ds,ax	
```

这段代码就是用汇编语言写的，含义是把0x07c0这个值复制到ax寄存器里，再将ax寄存器里的值复制到ds寄存器里。那其实这一番折腾的结果就是让ds寄存器的值编程了0x07c0。

![](/images/os/4.png)

ds是一个16位的段寄存器，具体表示数据段寄存器，在内存寻址时充当段基址的作用。就是说，当我们之后用汇编语言写一个内存地址时，实际上仅仅写了偏移地址，比如：

```asm
mov ax,[0x0001]
mov ax,[ds:0x0001]
```

ds是默认加上的，表示在ds这个段基址处，往后再偏移0x0001单位，将这个位置的内存数据，复制到ax寄存器中。

ds这个数据段寄存器的作用就是如此，方便描述一个内存地址时，可以省略一个基质，没什么神奇之处。

```txt
ds:0x0001
北京市:天安门
```

再看，这个ds被赋值为了0x7c0，由于X86为了让自己在16位这个实模式下能访问到20位的地址线的这个历史因素（这里不去纠结为啥了），所以段基质要先左移四位。那0x07c0左移四位就是0x07c00，这就刚好和这段代码被BIOS加载到内存地址0x7c00一样了。

也就是说，之后写的代码，里面访问的数据的内存地址，都先默认加上了0x7c00，再去内存中寻址。

为啥统一加上0x7c00？很好解释，BIOS规定死了把操作系统代码加载到内存0x7c00，那么里面的各种数据自然就全都被便宜了这么多，所以把数据段寄存器ds设置为这个值，方便了以后通过这种基址的方式访问内存里的数据。

![](/images/os/5.png)

### 第二段代码

```asm
mov ax,0x9000
mov es,ax
mov cx,#256
sub si,si
sub di,di
rep movw
```

此时，ds寄存器的值已经是0x07c0，然后又通过同样的方式将es的值变成0x9000，接着又把cx寄存器的值编程256.

在往下看，有两个sub指令，sub指令比较简单

```asm
sub si,si
```

就是si = si- si

所以这里就是把这个寄存器里的值清零，这是一个基本玩法。

那么现在CPU寄存器的值就是这样了。

![](/images/os/6.png)

这里为什么要给寄存器赋值？就是为了下一条指令服务的，就是

```asm
rep movw
```

这里**rep 表示重复执行后面的指令**

而后面的指令movw表示复制一个字(word 16位)，其实就是不断重复地复制一个字。

**重复执行的次数呢？**--- **是cx寄存器中的值256次**

**从哪里复制到哪里呢** --- **是从ds:si出复制到es:di处**

**一次复制多少呢** --- **复制一个字  word 16 位 两个字节**

那么整理一下就是，将内存地址0x7c00处开始往后的512字节的数据，原封不动复制到0x90000处。

就是下图的2.复制过程

![](/images/os/7.png)

这么折腾一下，操作系统最开始的代码已经是0x90000这个位置。

再往后就是一个跳转指令。

```asm
jmpi go,0x9000
go:
	mov ax,cs
	mov ds,ax
```

这里干了啥呢？

**jmpi就是一个段间跳转指令，表示跳转到0x9000:go处执行**

这里段基址：偏移地址这种格式的内存地址要如何计算呢？段基址仍然要先左移四位，因此结论就是跳转到0x90000 + go这个内存地址处执行。

再说go，go就是一个标签，最终编译成机器码的时候会被翻译成一个值，这个值就是go这个标签在文件内的偏移地址。

这个偏移地址再加上0x90000，就刚好是go标签后面那段代码mov ax,cs此时所在的内存地址。

![](/images/os/8.png)

那假如mov ax,cx这行代码位于最终编译好后的二进制文件的0x08处，那go就等于0x08，而最终跳转到的地址就是0x90008处。

### 第三段代码

接下来我们看一下go这个标签的位置跟着CPU的步伐往后看。

```asm
go: mov ax,cs
		mov ds,ax
		mov es,ax
		mov ss,ax
		mov sp,#0xFF00
```

这段代码全都是mov操作，那么意思就很容易理解了，就是把cs寄存器的值分别复制给ds,es,和ss寄存器，然后又把0xFF00给了sp寄存器。

回顾下CPU寄存器图。

![](/images/os/9.png)

cs寄存器表示**代码段寄存器**，CPU当前正在执行的代码在内存中的位置，就是由cs:ip这组寄存器配合指向的，其中cs是基址，ip是偏移地址。

由于之前执行过一个段间跳转指令

```asm
jmpi go 0x9000
```

所以现在cs寄存器里的值就是0x9000，ip寄存器里的值就是go这个标签的偏移地址。那这三个mov指令就分别给ds、es和ss寄存器赋值为了0x9000。

ds为数据段寄存器，之前就说过，当时它被复制为0x07c0，是因为之前的代码在0x7c00处，现在代码已经被挪到了0x90000处，所以现在自然又改赋值为0x9000了。

es是扩展段寄存器，仅仅是一个扩展，不是主角。

ss为栈段寄存器，后面要配合栈基址寄存器sp来表示此时的栈顶地址。而此时sp寄存器被复制为了0xFF00了，所以目前的栈顶地址就是ss:sp所指向的地址0x9FF00处。

![](/images/os/10.png)

## 总结

那么到这里，操作系统的一些最最基础的准备工作，就做好了。都做了些啥事呢？

**第一**，代码从硬盘移到了内存，又从内存挪了个地方，放在了0x90000处。

**第二**，数据段寄存器ds和代码段寄存器cs此时都被设置为了0x9000，也就为跳转代码和访问内存数据，奠定了同一个内存的基址地址，方便了跳转和内存访问，因为仅仅需要指定偏移地址即可。

**第三**，栈顶地址被设置为了0x9FF00，具体表现为栈段寄存器ss为0x9000，**栈段寄存器**sp为0xFF00。栈是往下发展的，这个栈顶地址0x9FF000要远远大于此时代码所在的位置0x90000，所以栈向下发展就很难撞见代码所在的位置，也就比较安全。这也是为什么给栈顶地址设置为这个值的原因，其实只需要离代码的位置远远的即可。

总结说一下，**这一部分其实就是把代码段寄存器cs，数据段寄存器ds，栈段寄存器ss和栈基址寄存器sp**分别设置好了值，方别后续使用。

换个说法，其实操作系统做的事情，就是给如何访问代码，如何访问数据，如何访问栈进行了一下内存的初步规划。其中访问代码和访问数据的规划方式就是设置了一个基址而已，访问栈就是把栈顶指针指向了一个远离代码位置的地方而已。



