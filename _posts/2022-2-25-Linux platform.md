---
layout: post
title: Linux platform
date: 2022-2-25
---

今天觉得关于linux platform设备驱动的整个流程还不是很清晰，因此这里开始进行一次比较全面的复盘和回顾。并在Mizar板子上运行相关实验。

## 前言

关于linux驱动方向上，IO的读写操作最为简单，可以通过已有的实验进行回顾。但是像I2C、SPI、LCD等这些复杂的外设的驱动就不能这么简单的去写了，Linux系统要考虑到驱动的可重用性，因此提出了驱动的分离与分层这样的软件思路，在这个思路下诞生了我们经常打交道的platform设备驱动，也叫平台设备驱动。那么这里就具体介绍一下Linux下的驱动分离与分层，以及platform框架下的设备驱动如何去写。

## Linux驱动的分离与分层

### 驱动的分隔与分离

对于Linux这样一个成熟、庞大、复杂的操作系统，代码的重用性非常重要，否则的话就会在Linux内核中存在大量无意义的重复代码。尤其是驱动程序，因为驱动程序占用了Linux内核代码量的大头，如果不对驱动程序加以管理，任由重复的代码肆意增加，那么用不了多久Linux内核的文件数量就庞大到无法接受的地步。

假如现在有三个平台A、B、C这三个平台（这里的平台说的是SOC）上都有MPU6050这个I2C接口的六轴传感器，按照我们写逻辑的I2C驱动的思路，每个平台都要有一个MPU6050的驱动，因此编写出来的最简单的驱动框架如图所示：

![](/images/linux/platform0.png)

